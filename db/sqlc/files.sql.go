// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: files.sql

package database

import (
	"context"
	"database/sql"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (file_name, original_name, file_path, file_size, mime_type, description, category, uploaded_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, file_name, original_name, file_path, file_size, mime_type, description, category, uploaded_by, created_at, updated_at
`

type CreateFileParams struct {
	FileName     string         `db:"file_name" json:"file_name"`
	OriginalName string         `db:"original_name" json:"original_name"`
	FilePath     string         `db:"file_path" json:"file_path"`
	FileSize     int64          `db:"file_size" json:"file_size"`
	MimeType     string         `db:"mime_type" json:"mime_type"`
	Description  sql.NullString `db:"description" json:"description"`
	Category     sql.NullString `db:"category" json:"category"`
	UploadedBy   int32          `db:"uploaded_by" json:"uploaded_by"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (Files, error) {
	row := q.queryRow(ctx, q.createFileStmt, createFile,
		arg.FileName,
		arg.OriginalName,
		arg.FilePath,
		arg.FileSize,
		arg.MimeType,
		arg.Description,
		arg.Category,
		arg.UploadedBy,
	)
	var i Files
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.OriginalName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Description,
		&i.Category,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteFileStmt, deleteFile, id)
	return err
}

const getAllFiles = `-- name: GetAllFiles :many
SELECT id, file_name, original_name, file_path, file_size, mime_type, description, category, uploaded_by, created_at, updated_at FROM files
ORDER BY created_at DESC
`

func (q *Queries) GetAllFiles(ctx context.Context) ([]Files, error) {
	rows, err := q.query(ctx, q.getAllFilesStmt, getAllFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Files{}
	for rows.Next() {
		var i Files
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalName,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.Description,
			&i.Category,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFile = `-- name: GetFile :one
SELECT id, file_name, original_name, file_path, file_size, mime_type, description, category, uploaded_by, created_at, updated_at FROM files
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFile(ctx context.Context, id int32) (Files, error) {
	row := q.queryRow(ctx, q.getFileStmt, getFile, id)
	var i Files
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.OriginalName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Description,
		&i.Category,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFilesByUser = `-- name: GetFilesByUser :many
SELECT id, file_name, original_name, file_path, file_size, mime_type, description, category, uploaded_by, created_at, updated_at FROM files
WHERE uploaded_by = $1
ORDER BY created_at DESC
`

func (q *Queries) GetFilesByUser(ctx context.Context, uploadedBy int32) ([]Files, error) {
	rows, err := q.query(ctx, q.getFilesByUserStmt, getFilesByUser, uploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Files{}
	for rows.Next() {
		var i Files
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalName,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.Description,
			&i.Category,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET description = $2, category = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, file_name, original_name, file_path, file_size, mime_type, description, category, uploaded_by, created_at, updated_at
`

type UpdateFileParams struct {
	ID          int32          `db:"id" json:"id"`
	Description sql.NullString `db:"description" json:"description"`
	Category    sql.NullString `db:"category" json:"category"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (Files, error) {
	row := q.queryRow(ctx, q.updateFileStmt, updateFile, arg.ID, arg.Description, arg.Category)
	var i Files
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.OriginalName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Description,
		&i.Category,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
